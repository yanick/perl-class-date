=head1 NAME

Class::Date - Class for easy date and time manipulation

=head1 SYNOPSIS

  use Class::Date qw(date localdate gmdate now -DateParse);

  # creating non-timezones date object ('floating' time)
  $date = new Class::Date [$year,$month,$day,$hour,$min,$sec];
  $date = date [$year,$month,$day,$hour,$min,$sec];
  $date = date { year => $year, month => $month, day => $day,
                 hour => $hour, min   => $min,   sec => $sec };

  $date = date "2001-11-12 07:13:12";  # or any ISO-8601 format

  # add a month to it:
  $date += "1M";
  $date += "P1M";         # ISO-8601 Periods supported
  $date += [0,1,0,0,0,0]; # above formats supported
  $date += 31*24*60*60;   # seconds

  # intuitive arithmetic between dates:
  $days_between = ( date('2001-11-12')
                    - date('2001-07-04') )->day; # prints 131

  # creating date object in local timezone
  $date = localdate "2001-12-11";      # force local time
  $date = now;                         # the same as date(time)

  # creating absolute date object (UTC)
  $date = new Class::Date [$yyyy,$mm,$dd,$HH,$MM,$SS], 'UTC';
  $date = gmdate "2001-11-12 17:13";

  # creating absolute date object in any other timezone
  $date = date [$year,$month,$day,$hour,$min,$sec], 'Iceland';
  $date = date "2001-11-12 17:13", 'Iceland';

  # getting parts out - comprehensive methods available
  my $year = $date->year;     # full
  my $year_C = $date->_year;  # year - 1900 (or 1904 on Mac)
  my $month = $date->mon;     # 1..12
  my $month_C = $date->_mon;  # 0..11
  ($year,$month,$day,$hour,$min,$sec)=$date->array;
  print date([2001,12,11,4,5,6])->truncate;
                               # will print "2001-12-11"

  # constructing new date based on an existing one:
  $new_date = $date->clone;
  $new_date->set( year => 1977, sec => 14);
  $new_date = $date->clone( year => 1977, sec => 14 );

  # constructing a new date, which is the same absolute time as
  # the original, but expressed in another timezone:
  $new_date = $date->to_tz('Iceland');

  # comparison between absolute dates
  print $date1 > $date2 ? "I am older" : "I am younger";

  # comparison between relative dates
  print $reldate1 > $reldate2 ? "I am faster" : "I am slower";

  # Adding / Subtracting months and years are sometimes tricky:
  print date("2001-01-29") + '1M' - '1M'; # gives "2001-02-01"
  print date("2000-02-29") + '1Y' - '1Y'; # gives "2000-03-01"

=head1 DESCRIPTION

This module is intended to provide a general-purpose date, time and
combined date/time type for Perl.  You have a Class::Date class for
absolute date and date/time, and have a L<Class::Date::Rel> class for
relative dates, or I<periods>.

You can use the C<+>, C<->, C<E<lt>> and C<E<gt>> operators as with
native perl data types.

=head1 USAGE

Class::Date operations fall into these categories:

=over

=item  *

creating a new date object from some representation of a date

=item  *

performing operations on a date object (+, -, comparison)

=item  *

getting results, or parts of results back

=back

=head1 Creating a new date object

You can create a date object by the "date", "localdate", "gmdate" or
"isodate" function, or by calling the C<Class::Date-E<gt>new()>
constructor.

C<date()> and C<Class::Date-E<gt>new()> are equivalent, both have two
arguments: The date and (optionally) the timezone.

  $date1 = date [2000,11,12];
  $date2 = Class::Date->new([2000,06,11,13,11,22],'GMT');
  $date2 = $date1->new([2000,06,11,13,11,22]);

B<note:> you cannot simply supply the return from list context
C<CORE::localtime()> or C<CORE::gmtime()> (see L<perlfunc/localtime>
and L<perlfunc/gmtime>) to C<Class::Date-E<gt>new([])>; you would need
to add 1900 (or possibly 1904) to the year value first, add one to the
month, etc.  Use the C<now()> function, or see below for a more
reliable method.

You can also supply the date information in scalar form, or hashref:

  $date = date("2003-12-31 12:56:59");
  $date = date("2003-12-31 12:56:59 +12:00");
  $date = date({ year => 2003, month => 12, day => 31,
                 hour => 12,   min   => 56, sec => 59 },
               'Pacific/Auckland');
  $date = date   (20031231);     #Thu Aug 20 20:13:51 1970
  $date = isodate("20031231");   #Wed Dec 31  0:00:00 2003

See L</Valid Date Formats> for more information on the allowable
formats of the date.

Dates may be I<cloned> using the constructor, or the C<clone()>
method:

  $date2 = $date->new();
  $date2 = $date->clone();
  $date2 = $date->clone( year => $year,  sec => $sec );

=head2 How the Timezone is determined

When constructing a new date from scratch, if the timezone information
is omitted, then the date is "floating" (unless you set
C<$Class::Date::DEFAULT_TIMEZONE>).

If the date is being extracted from the system clock, then it always
has a time zone set.

You can override this behaviour to always assume the local time zone,
by setting C<$Class::Date::DEFAULT_TIMEZONE> to
C<$Class::Date::LOCAL_TIMEZONE>.  This behaviour mimics the behaviour
of earlier versions (1.1.x and below).

C<localdate $x> is equivalent to C<date $x,
$Class::Date::LOCAL_TIMEZONE>, and C<gmdate $x> is equivalent to
C<date $x, 'UTC'>

  $date1 = localdate [2000,11,12];
  $date2 = gmdate [2000,4,2,3,33,33];

  $date = localdate(time);

The I<time offset> can also be specified in ISO-8601 notation; however
it is still specifying a fixed point in time, rather than a floating
time.

  $date = date("2001-01-17 10:10:00 +12:00");
  print $date->tz;   # prints "+12:00"

  print date("2001-01-17 10:10:00 +02:00")
             ->to_tz("Pacific/Auckland");
    # prints "2001-01-17 21:10:00 +13:00"

=head2 Valid Date Formats

=over

=item ISO-8601 formats (scalar)

All ISO-8601 formats (but see L</BUGS AND LIMITATIONS>) are supported
for the scalar use; for example:

Dates:

  YY               (iso only)
  -MM
  --DD
  YY-MM
  YYYY             (iso only)
  YYDDD            (iso only)
  YY-DDD
  YYYYMM           (iso only)
  YYYY-MM
  YYYYDDD          (iso only)
  YYYYMMDD         (iso only)
  YY-MM-DD
  YYYY-MM-DD
  YYYYWNN
  YYYYWNND

(note: the W is a literal C<W> or C<w>, and is for specifying the week
of the year, then 01 to 54).

Times (must be preceded/seperated from the date with a literal C<T> or
C<t> where ambiguous with the above forms, or follow a complete date
with a space):

  HH
  HH.HHH...
  HH,HHH...
  HH:MM
  HHMM
  HH:MM.MMM...
  HH:MM,MMM...
  HH:MM:SS
  HHMMSS
  HH:MM:SS.SSS...
  HH:MM:SS,SSS...

=item 973897262

A valid 32-bit integer: This is parsed as a unix time.

However, this is ambiguous with compact ISO-8601 date forms above.  To
resolve this ambiguity, B<unix epoch seconds take precedence with
C<new()> and C<date()> constructors, but not the C<isodate()>
constructor.

  $date = date(time());

=item [$year, $month, $day, $hour, $min, $sec]

An array reference with 6 elements. The missing elements have default
values (year: 2000, month, day: 1, hour, min, sec: 0)

=item { year => $year, month => $month, day => $day, hour => $hour, min => $min, sec => $sec }

A hash reference with the same 6 elements as above.

=item additional input formats

You can specify C<-DateParse> as  an import parameter, e.g:

  use Class::Date qw(date -DateParse);

With this, the module will try to load L<Date::Parse>, and if it find
it then all these formats can be used as an input.  ()

This means, that with a little extra compile-time and at slightly
slower rates, you can parse dates with formats like these:

   1995:01:24T09:08:17.1823213           ISO-8601
   1995-01-24T09:08:17.1823213
   Wed, 16 Jun 94 07:29:35 CST           Comma and day name are optional
   Thu, 13 Oct 94 10:13:13 -0700
   Wed, 9 Nov 1994 09:50:32 -0500 (EST)  Text in ()'s will be ignored.
   21 dec 17:05
   21-dec 17:05
   21/dec 17:05
   21/dec/93 17:05
   1999 10:02:18 "GMT"
   16 Nov 94 22:28:20 PST

See L<Date::Parse> for more.

=back

=back

=cut

=head2 Extracting out Parts of a Date Object

A wide variety of methods are exported, to be able to extract out
the fields in slightly different ways:

  # quick "outs"
  $date->hms          # 01:23:45
  $date->ymd          # 2000/02/29
  $date->mdy          # 02/29/2000
  $date->dmy          # 29/02/2000

  # all others, just make up a sub name, this will leave a
  # compiled sub to 

  $date->YmdHMS

  $date->string       # 2000-02-29 12:21:11 (format can be changed, look below)
  "$date"             # same as prev.
  # getting values of an absolute date object
  $date;              # prints the date in default output format (see below)
  $date->yr;          # 2-digit year 0-99, e.g 1
  $date->year;        # year, e.g: 2001
  $date->_year;       # C year (year - 1900 on Unix), e.g. 101

  $date->mon;         # month 1..12
  $date->month;       # same as prev.
  $date->_mon;        # month 0..11
  $date->_month;      # same as prev.

  $date->mday;        # day of month
  $date->day;         # day of month
  $date->day_of_month;# same as prev.

  $date->wday;        # 1 = Sunday
  $date->_wday;       # 0 = Sunday
  $date->day_of_week; # same as prev.

  $date->hour;
  $date->min;
  $date->minute;      # same as prev.
  $date->sec;
  $date->second;      # same as prev.
  $date->yday;        
  $date->day_of_year; # same as prev.
  $date->isdst;       # DST?
  $date->daylight_savings; # same as prev.
  $date->epoch;       # UNIX time_t
  $date->monname;     # name of month, eg: March
  $date->monthname;   # same as prev.
  $date->wdayname;    # Thursday
  $date->day_of_weekname # same as prev.

  $date->tzoffset     # timezone-offset, eg: +12
  $date->strftime($format) # POSIX strftime (without the huge POSIX.pm)
  $date->tz           # returns the base timezone as you specify, eg: CET
  $date->tzdst        # returns the real timezone with dst information, eg: CEST

  # !! $year: 1900-, $month: 1-12
  ($year,$month,$day,$hour,$min,$sec)=@{ $date->aref };

  # !! $year: 0-, $month: 0-11
  ($sec,$min,$hour,$day,$mon,$year,$wday,$yday,$isdst)=$date->struct;
  ($sec,$min,$hour,$day,$mon,$year,$wday,$yday,$isdst)=@{ $date->sref };

  $hash=$date->href; # $href can be reused as a constructor
  print $hash->{year}."-".$hash->{month}. ... $hash->{sec} ... ;
  
  %hash=$date->hash;
  # !! $hash{year}: 1900-, $hash{month}: 1-12

  $date->month_begin  # First day of the month (date object)
  $date->month_end    # Last day of the month
  $date->days_in_month # 28..31

=head2 Operations

=over 4

=item addition

You can add the following to a Class::Date object:

  - a valid Class::Date::Rel object
  - anything, that can be used for creating a new Class::Date::Rel object

It means that you don't need to create a new Class::Date::Rel object every
time when you add something to the Class::Date object, it creates them
automatically:

  $date= Class::Date->new('2001-12-11')+Class::Date::Rel->new('3Y');

is the same as:

  $date= date('2001-12-11')+'3Y';

You can provide a Class::Date::Rel object in the following form:

  $reldate = new Class::Date::Rel [$YYYY,$mm,$dd,$HH,$MM,$SS];
  $reldate = new Class::Date::Rel
       { year => $year, month => $month, day => $day,
         hour => $hour, min   => $min,   sec => $sec };

  $reldate = new Class::Date::Rel "2001-11-12 07:13:12";
  $reldate = new Class::Date::Rel "2001-12-11";

=over 4

=item array ref

The same format as seen in Class::Date format, except the default values are
different: all zero.

=item hash ref

The same format as seen in Class::Date format, except the default values are
different: all zero.

=item "973897262"

A valid 32-bit integer is parsed as seconds.

=item "YYYY-MM-DD hh:mm:ss"

A standard ISO date format, but this is parsed as relative date date and time,
so month, day and year can be zero (and defaults to zero).

=item "12Y 6M 6D 20h 12m 5s"

This special string can be used if you don't want to use the ISO format. This
string consists of whitespace separated tags, each tag consists of a number and
a unit. The units can be:

  Y: year
  M: month
  D: day
  h: hour
  m: min
  s: sec

The number and unit must be written with no space between them.

=back

=item substraction

The same rules are true for substraction, except you can substract 
two Class::Date object from each other, and you will get a Class::Date::Rel
object:

  $reldate=$date1-$date2;
  $reldate=date('2001-11-12 12:11:07')-date('2001-10-07 10:3:21');

In this case, the "month" field of the $reldate object will be 0,
and the other fields will contain the difference between two dates;

=item comparison

You can compare two Class::Date objects, or one Class::Date object and
another data, which can be used for creating a new Class::Data object.

It means that you don't need to bless both objects, one of them can be a
simple string, array ref, hash ref, etc (see how to create a date object).

  if ( date('2001-11-12') > date('2000-11-11') ) { ... }

or 

  if ( date('2001-11-12') > '2000-11-11' ) { ... }

=item truncate

You can chop the time value from this object (set hour, min and sec to 0)
with the "truncate" or "trunc" method. It does not modify the specified
object, it returns with a new one.

=item clone

You can create new date object based on an existing one, by using the "clone"
method. Note, this DOES NOT modify the base object.

  $new_date = $date->clone( year => 2001, hour => 14 );

The valid keys are: year, _year, month, mon, _month, _mon, day, mday, 
day_of_month, hour, min, minute, sec, second, tz.

There is a "set" method, which does the same as the "clone", it exists 
only for compatibility.

=item to_tz

You can use "to_tz" to create a new object, which means the same time as
the base object, but in the different timezone.

Note that $date->clone( tz => 'Iceland') and $date->to_tz('Iceland') is not
the same! Cloning a new object with setting timezone will preserve the
time information (hour, minute, second, etc.), but transfer the time into
other timezone, while to_tz usually change these values based on the
difference between the source and the destination timezone.

=item Operations with Class::Date::Rel

  # creating relative date object (a "Period")
  # (normally you don't need to create this object explicitly)
  $reldate = new Class::Date::Rel "3Y 1M 3D 6h 2m 4s";
  $reldate = new Class::Date::Rel "P3Y1M3DT6H2M4S";  # ISO-8601
  $reldate = new Class::Date::Rel "6Y";
  $reldate = new Class::Date::Rel $secs;  # secs
  # or any format supported by `Class::Date->new'

  # getting values of a relative date object
  $reldate;              # reldate in seconds (assumed 1 month = 2_629_744 secs)
  $reldate->year;
  $reldate->mon;
  $reldate->month;       # same as prev.
  $reldate->day;
  $reldate->hour;
  $reldate->min;
  $reldate->minute;      # same as prev.
  $reldate->sec;         # same as $reldate
  $reldate->second;      # same as prev.
  $reldate->sec_part;    # "second" part of the relative date
  $reldate->mon_part;    # "month"  part of the relative date

  # arithmetic with dates:
  print date([2001,12,11,4,5,6])->truncate; 
                               # will print "2001-12-11"
  $new_date = $date+$reldate;
  $date2    = $date+'3Y 2D';   # 3 Years and 2 days
  $date3    = $date+[1,2,3];   # $date plus 1 year, 2 months, 3 days
  $date4    = $date+'3-1-5'    # $date plus 3 years, 1 months, 5 days

  $new_date = $date-$reldate;
  $date2    = $date-'3Y';      # 3 Yearss
  $date3    = $date-[1,2,3];   # $date minus 1 year, 2 months, 3 days
  $date4    = $date-'3-1-5'    # $date minus 3 years, 1 month, 5 days

  $new_reldate = $date1-$date2;
  $reldate2 = Class::Date->new('2000-11-12')-'2000-11-10';
  $reldate3    = $date3-'1977-11-10';

  # Named interface ($date2 does not necessary to be a Class::Date object)
  $date1->string;               # same as $date1 in scalar context
  $date1->subtract($date2);     # same as $date1 - $date2
  $date1->add($date2);          # same as $date1 + $date2
  $date1->compare($date2);      # same as $date1 <=> $date2

  $reldate1->sec;               # same as $reldate1 in numeric or scalar context
  $reldate1->compare($reldate2);# same as $reldate1 <=> $reldate2
  $reldate1->add($reldate2);    # same as $reldate1 + $reldate2
  $reldate1->neg                # used for subtraction

  # Disabling Class::Date warnings at load time
  BEGIN { $Class::Date::WARNINGS=0; }
  use Class::Date;

The Class::Date::Rel object consists of a month part and a day part. Most
people only use the "day" part of it. If you use both part, then you can get
these parts with the "sec_part" and "mon_part" method. If you use "sec",
"month", etc. methods or if you use this object in a mathematical conent,
then this object is converted to one number, which is interpreted as second.
The conversion is based on a 30.436 days month. Don't use it too often,
because it is confusing...

If you use Class::Date::Rel in an expression with other Class::Date or
Class::Date::Rel objects, then it does what is expected: 

  date('2001-11-12')+'1M' will be '2001-12-12'

and

  date('1996-02-11')+'2M' will be '1996-04-11'

=back

=head2 Accessing data from a Class::Date and Class::Date::Rel object

You can use the methods methods described at the top of the document 
if you want to access parts of the data
which is stored in a Class::Date and Class::Date::Rel object.


=head2 Configuration Variables

  # configuring the `stringify' date format
  {
    local $Class::Date::DATE_FORMAT="%Y%m%d%H%M%S";
    print $date       # result: 20011222000000
    $Class::Date::DATE_FORMAT=undef;
    print $date       # result: Thu Oct 13 04:54:34 1994
    $Class::Date::DATE_FORMAT="%Y/%m/%d"
    print $date       # result: 1994/10/13
  }

  # adjusting DST in calculations  (see the doc)
  $Class::Date::DST_ADJUST = 1; # this is the default
  $Class::Date::DST_ADJUST = 0;

  # "month-border adjust" flag 
  $Class::Date::MONTH_BORDER_ADJUST = 0; # this is the default
  print date("2001-01-31")+'1M'; # will print 2001-03-03
  $Class::Date::MONTH_BORDER_ADJUST = 1;
  print date("2001-01-31")+'1M'; # will print 2001-02-28

  # date range check
  $Class::Date::RANGE_CHECK = 0; # this is the default
  print date("2001-02-31"); # will print 2001-03-03
  $Class::Date::RANGE_CHECK = 1;
  print date("2001-02-31"); # will print nothing

=head2 Error handling

If a date object became invalid, then the object will be reblessed to
Class::Date::Invalid. This object is false in boolean environment, so you can
test the date validity like this:

  # error handling
  {
    use Class::Date qw(:errors date);
    $a = date($date_string);
    if ($a) { # valid date
      ...
    } else { # invalid date
      if ($a->error == E_INVALID) { ... }
      print $a->errstr;
    }
  }

  $a = date($input_date);
  if ($a) { # valid date
      ...
  } else { # invalid date
      if ($a->error == E_INVALID) { ... }
      print $a->errstr;
  }

Note even the date is invalid, the expression "defined $a" always returns
true, so the following is wrong:

  $a = date($input_date);
  if (defined $a) ... # WRONG!!!!

You can test the error by getting the $date->error value. You might import
the ":errors" tag:

  use Class::Date qw(:errors);

Possible error values are:

=over 4

=item E_OK

No errors.

=item E_INVALID

Invalid date. It is set when some of the parts of the date are invalid, and
Time::Local functions cannot convert them to a valid date.

=item E_RANGE

This error is set, when parts of the date are valid, but the whole date is
not valid, e.g. 2001-02-31. When the $Class::Date::RANGE_CHECK is not set, then
these date values are automatically converted to a valid date: 2001-03-03,
but the $date->error value are set to E_RANGE. If $Class::Date::RANGE_CHECK
is set, then a date "2001-02-31" became invalid date.

=item E_UNPARSABLE

This error is set, when the constructor cannot be created from a scalar, e.g:

  $a = date("4kd sdlsdf lwekrmk");

=item E_UNDEFINED

This error is set, when you want to create a date object from an undefined
value:

  $a = new Class::Date (undef);

Note, that localdate(undef) will create a valid object, because it calls
$Class::Date(time).

=back

You can get the error in string form by calling the "errstr" method.

=head1 DST_ADJUST

$DST_ADJUST is an importable variable, and is a very important configuration
option.

If it is set to true (default), then it adjusts the date and time when the
operation switches the border of DST. You will see the difference if you run
this code:

  $Class::Date::DST_ADJUST=0;
  for (my $date=localdate("2000-06-11");$date<"2001-4-5";$date+='1D') {
    print $date."\n";
  }

  $Class::Date::DST_ADJUST=1;
  for (my $date=localdate("2000-06-11");$date<"2001-4-5";$date+='1D') {
    print $date."\n";
  }

=head1 MONTHS AND YEARS

If you add or subtract "months" and "years" to a date, you may get wrong 
dates, e.g when you add one month to 2001-01-31, you expect to get
2001-02-31, but this date is invalid and converted to 2001-03-03. Thats' why

  date("2001-01-31") + '1M' - '1M' != "2001-01-31"

This problem can occur only with months and years, because others can 
easily be converted to seconds.

=head1 MONTH_BORDER_ADJUST

$MONTH_BORDER_ADJUST variable is used to switch on or off the 
month-adjust feature. This is used only when someone adds months or years to
a date and then the resulted date became invalid. An example: adding one
month to "2001-01-31" will result "2001-02-31", and this is an invalid date.

When $MONTH_BORDER_ADJUST is false, this result simply normalized, and
becomes "2001-03-03". This is the default behaviour.

When $MONTH_BORDER_ADJUST is true, this result becomes "2001-02-28". So when
the date overflows, then it returns the last day insted.

Both settings keeps the time information.

=head1 WORKING WITHOUT A C COMPILER

Class::Date can be used without a C compiler since 1.0.8. If you want to do 
this, you only need to copy the "Date.pm" whereever your perl compiler searches
for it. You must make a "Class" directory for it before.

In Debian GNU/Linux system (woody) , a good choice can be the following:

  mkdir /usr/local/share/perl/5.6.1/Class
  cp Date.pm /usr/local/share/perl/5.6.1/Class

And the module will work.

You can use the $WARNINGS switch to switch off the complains about the missing
XS part from your perl program:

    BEGIN { $Class::Date::WARNINGS=0; }
    use Class::Date;
    ...

=head1 TIMEZONE SUPPORT

Since 1.0.11, Class::Date handle timezones natively on most platforms (see
the BUGS AND LIMITATIONS section for more info).

When the module is loaded, then it determines the local base timezone by
calling the Class::Date::local_timezone() function, and stores these values
into two variables, these are: $Class::Date::LOCAL_TIMEZONE and
$Class::Date::DEFAULT_TIMEZONE. The first value is used, when you call the
"localdate" function, the second value is used, when you call the "date"
function and you don't specify the timezone. There is
a $Class::Date::GMT_TIMEZONE function also, which is used by the "gmdate"
function, this is set to 'GMT'.

You can query the timezone of a date object by calling the $date->tz
method. Note this value returns the timezone as you specify, so if you
create the object with an unknown timezone, you will get this back. If you
want to query the effective timezone, you can call the $date->tzdst method.
This method returns only valid timezones, but it is not necessarily the
timezone, which can be used to create a new object. For example
$date->tzdst can return 'CEST', which is not a valid base timezone, because
it contains daylight savings information also. On Linux systems, you can
see the possible base timezones in the /usr/share/zoneinfo directory.

In Class::Date 1.1.6, a new environment variable is introduced:
$Class::Date::NOTZ_TIMEZONE. This variable stores the local timezone, which
is used, when the TZ environment variable is not set. It is introduced,
because there are some systems, which cannot handle the queried timezone
well. For example the local timezone is CST, it is returned by the tzname()
perl function, but when I set the TZ environment variable to CST, it
works like it would be GMT.  The workaround is NOTZ_TIMEZONE: if a date
object has a timezone, which is the same as NOTZ_TIMEZONE, then the TZ
variable will be removed before each calculation. In normal case, it would
be the same as setting TZ to $NOTZ_TIMEZONE, but some systems don't like
it, so I decided to introduce this variable. The
$Class::Date::NOTZ_TIMEZONE variable is set in the initialization of the
module by removing the TZ variable from the environment and querying the
tzname variable.

=head1 INTERNALS

This module uses operator overloading very heavily. I've found it quite stable,
but I am afraid of it a bit.

A Class::Date object is an array reference.

A Class::Date::Rel object is an array reference, which contains month and
second information. I need to store it as an array ref, because array and month
values cannot be converted into seconds, because of our super calendar.

You can add code references to the @Class::Date::NEW_FROM_SCALAR and
@Class::Date::Rel::NEW_FROM_SCALAR. These arrays are iterated through when a
scalar-format date must be parsed. These arrays only have one or two values
at initialization. The parameters which the code references got are the same 
as the "new" method of each class. In this way, you can personalize the date
parses as you want.

As of 0.90, the Class::Date has been rewritten. A lot of code and design
decision has been borrowed from Matt Sergeant's Time::Object, and there will
be some incompatibility with the previous public version (0.5). I tried to
keep compatibility methods in Class::Date. If you have problems regarding
this, please drop me an email with the description of the problem, and I will
set the compatibility back.

Invalid dates are Class::Date::Invalid objects. Every method call on this
object and every operation with this object returns undef or 0.

=head1 DEVELOPMENT FOCUS

This module tries to be as full-featured as can be. It currently lacks
business-day calculation, which is planned to be implemented in the 1.0.x
series.

I try to keep this module not to depend on other modules and I want this
module usable without a C compiler.

Currently the module uses the POSIX localtime function very extensively.
This makes the date calculation a bit slow, but provides a rich interface,
which is not provided by any other module. When I tried to redesign the
internals to not depend on localtime, I failed, because there are no other
way to determine the daylight savings information.

=head1 SPEED ISSUES

There are two kind of adjustment in this module, DST_ADJUST and
MONTH_BORDER_ADJUST. Both of them makes the "+" and "-" operations
slower. If you don't need them, switch them off to achieve faster
calculations.

In general, if you really need I<fast> date and datetime calculation,
don't use this module. As you see in the previous section, the focus
of development is not the speed in 1.0.  For ultra-fast date and
datetime calculations (but no string date/time parsing, and no concept
of a Date object), use the L<Date::Calc> module instead.

[ Later contributor's note: As it turns out, I found this module to be
the fastest module on CPAN that supports a date object ]

If I<speed, memory and disk space consumption is no object> - and you
I<enjoy installing new modules> to interpret very straightforward time 
formats really, then you're better off with L<DateTime>.  As an
added bonus, you can get clean plug-ins to convert dates to the
Klingon calendar and for some definition of 'correct', correctly
handle all anomalies in the calendar, such as leap seconds and "the
fortnight that didn't exist" in 1582 (if you were a catholic, anyway).
It also apparently has a "Clean API", according to the author - and a
fine cargo cult following (enter C<cargo cult programming> to
L<http://www.dictionary.com> for an explanation of the term).

If I<run-time memory consumption> is your primary concern, you still
can't really look past the good ol' (that's Perl speak for old and
crusty) L<Date::Manip> module.  It might take almost as long as
L<DateTime> to parse dates (and B<even longer> (gasp!) for some)
- but its simple ISO-8601 in-memory representation sure is compact.

=head1 BUGS AND LIMITATIONS

=over 4

=item *

I cannot manage to get the timezone code working properly on ActivePerl
5.8.0 on win XP and earlier versions possibly have this problem also. If
you have a system like this, then you will have only two timezones, the
local and the GMT. Every timezone, which is not equal to
$Class::Date::GMT_TIMEZONE is assumed to be local. This seems to be caused
by the win32 implementation of timezone routines. I don't really know how
to make this thing working, so I gave up this issue. If anyone know a
working solution, then I will integrate it into Class::Date, but until
then, the timezone support will not be available for these platforms.

=item *

Perl 5.8.0 and earlier versions has a bug in the strftime code on some
operating systems (for example Linux), which is timezone related. I
recommend using the strftime, which is provided with Class::Date, so don't
try to use the module without the compiled part. The module will not work
with a buggy strftime - the test is hardcoded into the beginning of the
code. If you anyway want to use the module, remove the hardcoded "die" from
the module, but do it for your own risk.

=item *

This module uses the POSIX functions for date and
time calculations, so it is not working for dates beyond 2038 and before 1902.

I don't know what systems support dates in 1902-1970 range, it may not work on
your system. I know it works on the Linux glibc system with perl 5.6.1
and 5.7.2. I know it does not work with perl 5.005_03 (it may be the bug of
the Time::Local module). Please report if you know any system where it does
_not_ work with perl 5.6.1 or later.

I hope that someone will fix this with new time_t in libc. If you really need
dates over 2038 and before 1902, you need to completely rewrite this module or
use Date::Calc or other date modules.

=item *

This module uses Time::Local, and when it croaks, Class::Date returns
"Invalid date or time" error message. Time::Local is different in the 5.005
and 5.6.x (and even 5.7.x) version of perl, so the following code will
return different results:

  $a = date("2006-11-11")->clone(year => -1);

In perl 5.6.1, it returns an invalid date with error message "Invali date or
time", in perl 5.005 it returns an invalid date with range check error. Both
are false if you use them in boolean context though, only the error message
is different, but don't rely on the error message in this case. It however
works in the same way if you change other fields than "year" to an invalid
field.

=item *

Unfortunately, the ISO-8601 standards document is not free, and so it
is possible that some valid ISO-8601 formats are not understood by
this module.  For bibliography's sake, the information on these two
sites were the primary consult:

L<http://www.cl.cam.ac.uk/~mgk25/iso-time.html>

L<http://www.mcs.vuw.ac.nz/technical/software/SGML/doc/iso8601/ISO8601.html>

=back

=head1 SUPPORT

Class::Date is free software. IT COMES WITHOUT WARRANTY OF ANY KIND.

If you have questions, you can send it to the Class::Date mailing list:

  class-date@lists.dlux.hu
  
You can subscribe to this list by a web-interface:

  http://lists.dlux.hu/wws/info/class-date

=head1 WIN32 notes

You can get a binary win32 version of Class::Date from Chris Winters' .ppd
repository with the following commands:

For people using PPM2:

  c:\> ppm
  PPM> set repository oi http://openinteract.sourceforge.net/ppmpackages/
  PPM> set save
  PPM> install Class-Date

For people using PPM3:

  c:\> ppm
  PPM> repository http://openinteract.sourceforge.net/ppmpackages/
  PPM> install Class-Date

The first steps in PPM only needs to be done at the first time. Next time
you just run the 'install'.

=head1 COPYRIGHT

Copyright (c) 2001 SzabÅÛ, BalÅ·zs (dLux)

All rights reserved. This program is free software; you can redistribute it 
and/or modify it under the same terms as Perl itself.

Portions Copyright (c) Matt Sergeant

=head1 AUTHOR

  dLux (SzabÅÛ, BalÅ·zs) <dlux@dlux.hu>

=head1 CREDITS

=over -

=item Matt Sergeant <matt@sergeant.org>

Lots of code are borrowed from the Time::Object module.

=item Tatsuhiko Miyagawa <miyagawa@cpan.org>

(bugfixes)

=item Stas Bekman <stas@stason.org>

(suggestions, bugfix)

=item Chris Winters <chris@cwinters.com>

(win32 .ppd version)

=item Benoit Beausejour <bbeausej@pobox.com>

Parts of the timezone code is borrowed from his Date::Handler module.

=item Sam Vilain <samv@cpan.org>

ISO-8601 support, and various manual page enhancements including the
snide comments about the L<DateTime> module.

=back


=head1 SEE ALSO

perl(1).
Date::Calc(3pm).
Time::Object(3pm).
Date::Handler(3pm).

=cut
                                              